<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C·∫£i ti·∫øn t∆∞∆°ng t√°c - Hand Physics</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            transform: scaleX(-1); 
        }
        video { display: none; } 
        .ui-overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>
        
        <div class="ui-overlay p-6">
            <div class="bg-black/70 text-white p-4 rounded-2xl backdrop-blur-xl border border-white/10 w-fit">
                <h1 class="text-xl font-bold text-blue-400 flex items-center gap-2">
                    <span>üñêÔ∏è</span> V·∫≠t l√Ω B√†n tay Pro
                </h1>
                <div class="mt-2 space-y-1 font-mono text-sm opacity-90">
                    <p id="ui-fingers">Ng√≥n tay: 0</p>
                    <p id="ui-status">Tr·∫°ng th√°i: ƒêang t√¨m tay...</p>
                    <p id="ui-boxes">S·ªë l∆∞·ª£ng h·ªôp: 1</p>
                </div>
            </div>

            <div class="absolute bottom-10 left-1/2 -translate-x-1/2 bg-black/50 backdrop-blur-md px-8 py-4 rounded-2xl border border-white/20 text-white text-center shadow-2xl">
                <p class="text-lg">üëå <span class="text-yellow-400 font-bold">Ch·ª•m ng√≥n c√°i & tr·ªè</span> ƒë·ªÉ C·∫ßm/N√©m</p>
                <p class="text-sm opacity-70 mt-1">üñêÔ∏è 5 ng√≥n: T·∫°o h·ªôp | ü§ü 3 ng√≥n: X√≥a h·ªôp</p>
            </div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        const uiFingers = document.getElementById('ui-fingers');
        const uiStatus = document.getElementById('ui-status');
        const uiBoxes = document.getElementById('ui-boxes');

        // C·∫•u h√¨nh v·∫≠t l√Ω & ph·∫£n h·ªìi
        const BOX_SIZE = 100;
        const GRAVITY = 0.9;
        const FRICTION = 0.75;
        const PINCH_THRESHOLD = 0.045; // base (t·ª∑ l·ªá m√†n h√¨nh)
        const HOLD_STIFFNESS = 0.22; // l·ª±c l√≤ xo khi c·∫ßm
        const HOLD_DAMPING = 0.75; // gi·∫£m ch·∫•n c·ªßa l√≤ xo
        const ROTATION_FRICTION = 0.995;
        const MAX_TRAIL = 10;
        
        let boxes = [];
        let heldBox = null;
        let lastActionTime = 0;
        let isFivePrev = false;
        let isThreePrev = false;
        let velocityHistory = [];
        let smoothed = {x: 0, y: 0};

        class Box {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.w = BOX_SIZE;
                this.h = BOX_SIZE;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = 0;
                this.angle = 0;
                this.av = 0; // angular velocity
                this.isHeld = false;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                this.trail = [];
                this.target = null;
            }

            update(width, height) {
                // Trail
                this.trail.push({x: this.x + this.w/2, y: this.y + this.h/2, a: 0.25});
                if (this.trail.length > MAX_TRAIL) this.trail.shift();

                if (this.isHeld && this.target) {
                    // Spring follow to make it feel like c·∫ßm c√≥ tr·ªçng l∆∞·ª£ng
                    const tx = this.target.x;
                    const ty = this.target.y;
                    this.vx += (tx - this.x) * HOLD_STIFFNESS;
                    this.vy += (ty - this.y) * HOLD_STIFFNESS;
                    this.vx *= HOLD_DAMPING;
                    this.vy *= HOLD_DAMPING;
                    this.x += this.vx;
                    this.y += this.vy;
                    // lock rotation while held: reset angular velocity and smoothly stabilize angle
                    this.av = 0;
                    this.angle += (0 - this.angle) * 0.22;
                } else {
                    this.vy += GRAVITY;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.av *= ROTATION_FRICTION;
                    this.angle += this.av;

                    if (this.y + this.h > height) {
                        this.y = height - this.h;
                        this.vy *= -FRICTION;
                        this.vx *= 0.95;
                        if (Math.abs(this.vy) < 1.5) this.vy = 0;
                    }
                    if (this.x < 0) {
                        this.x = 0;
                        this.vx *= -FRICTION;
                    } else if (this.x + this.w > width) {
                        this.x = width - this.w;
                        this.vx *= -FRICTION;
                    }
                    if (this.y < 0) {
                        this.y = 0;
                        this.vy *= -FRICTION;
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                // Draw soft drop shadow (ellipse)
                const shadowX = this.x + this.w/2 + Math.min(20, this.vx);
                const shadowY = this.y + this.h + 12;
                const grad = ctx.createRadialGradient(shadowX, shadowY, 5, shadowX, shadowY, 80);
                grad.addColorStop(0, 'rgba(0,0,0,0.45)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(shadowX, shadowY, this.w/1.6, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // Trail
                for (let i = 0; i < this.trail.length; i++) {
                    const p = this.trail[i];
                    const a = (i / this.trail.length) * 0.4;
                    ctx.fillStyle = `rgba(255,255,255,${a})`;
                    ctx.beginPath();
                    ctx.roundRect(p.x - this.w/4, p.y - this.h/4, this.w/2, this.h/2, 8);
                    ctx.fill();
                }

                // Box
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                ctx.rotate(this.angle);
                const scale = this.isHeld ? 1.06 : 1;
                ctx.scale(scale, scale);
                ctx.shadowBlur = this.isHeld ? 28 : 18;
                ctx.shadowColor = this.isHeld ? 'rgba(255,71,87,0.35)' : 'rgba(0,0,0,0.35)';
                ctx.fillStyle = this.isHeld ? '#ff4757' : this.color;

                const r = 18;
                ctx.beginPath();
                ctx.roundRect(-this.w/2, -this.h/2, this.w, this.h, r);
                ctx.fill();

                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = this.isHeld ? 5 : 2;
                ctx.stroke();

                // Text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(this.isHeld ? '' : '', 0, 6);

                ctx.restore();
            }
        }

        function onResults(results) {
            if (canvasElement.width !== window.innerWidth) {
                canvasElement.width = window.innerWidth;
                canvasElement.height = window.innerHeight;
                if(boxes.length === 0) boxes.push(new Box(window.innerWidth/2 - 50, 100));
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            let currentFingers = 0;
            let handDetected = false;
            let isPinching = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // Dynamic hand span (bigger hands => bigger tolerated pinch distance)
                const handSpanNorm = Math.hypot(landmarks[0].x - landmarks[9].x, landmarks[0].y - landmarks[9].y);
                const dynamicThreshold = PINCH_THRESHOLD * (1 + handSpanNorm * 1.6);

                // 1. T√≠nh to√°n c·ª≠ ch·ªâ ch·ª•m (Pinch)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                isPinching = distance < dynamicThreshold;

                const rawCx = (thumbTip.x + indexTip.x) / 2 * canvasElement.width;
                const rawCy = (thumbTip.y + indexTip.y) / 2 * canvasElement.height;

                // Smooth the pinch point to reduce jitter
                if (!smoothed.x && !smoothed.y) { smoothed.x = rawCx; smoothed.y = rawCy; }
                smoothed.x += (rawCx - smoothed.x) * 0.45;
                smoothed.y += (rawCy - smoothed.y) * 0.45;
                const cx = smoothed.x;
                const cy = smoothed.y;

                // 2. V·∫Ω khung x∆∞∆°ng b√†n tay
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                    color: isPinching ? '#ff4757' : '#00d2ff',
                    lineWidth: 5
                });
                drawLandmarks(canvasCtx, landmarks, {
                    color: isPinching ? '#ff4757' : '#ffffff',
                    lineWidth: 1,
                    radius: (data) => (data.index === 4 || data.index === 8) ? 8 : 3
                });

                // 3. ƒê·∫øm ng√≥n tay (tr·ª´ ng√≥n c√°i v√† ng√≥n tr·ªè khi ƒëang ch·ª•m)
                [12, 16, 20].forEach(i => { if(landmarks[i].y < landmarks[i-2].y) currentFingers++; });
                if(landmarks[8].y < landmarks[6].y) currentFingers++;
                if(Math.abs(landmarks[4].x - landmarks[2].x) > 0.05) currentFingers++;

                const now = Date.now();

                // Logic ƒëi·ªÅu khi·ªÉn: t·∫°o/x√≥a h·ªôp
                if (currentFingers === 5 && !isFivePrev && now - lastActionTime > 700) {
                    boxes.push(new Box(cx - 50, cy - 50));
                    lastActionTime = now;
                }
                isFivePrev = currentFingers === 5;

                if (currentFingers === 3 && !isThreePrev && boxes.length > 0) {
                    if (heldBox) heldBox = null;
                    boxes.pop();
                    lastActionTime = now;
                }
                isThreePrev = currentFingers === 3;

                // X·ª≠ l√Ω c·∫ßm n·∫Øm v·ªõi v√πng va ch·∫°m m·ªü r·ªông theo k√≠ch th∆∞·ªõc tay
                if (isPinching) {
                    velocityHistory.push({x: cx, y: cy, t: now});
                    if(velocityHistory.length > 8) velocityHistory.shift();

                    if (!heldBox) {
                        // T√≠nh hitPadding d·ª±a tr√™n k√≠ch th∆∞·ªõc tay (pixel)
                        const handSpanPx = handSpanNorm * canvasElement.width;
                        const hitPadding = Math.max(24, handSpanPx * 0.6);
                        for (let b of boxes) {
                            if (cx > b.x - hitPadding && cx < b.x + b.w + hitPadding &&
                                cy > b.y - hitPadding && cy < b.y + b.h + hitPadding) {
                                heldBox = b;
                                b.isHeld = true;
                                // reset angular motion and stabilize angle immediately when picked up
                                b.av = 0;
                                b.angle = 0;
                                b.trail = [];
                                b.target = {x: cx - b.w/2, y: cy - b.h/2};
                                break;
                            }
                        }
                    } else {
                        heldBox.target = {x: cx - heldBox.w/2, y: cy - heldBox.h/2};
                    }
                } else if (heldBox) {
                    // T√≠nh v·∫≠n t·ªëc khi th·∫£ ƒë·ªÉ n√©m t·ª± nhi√™n
                    if (velocityHistory.length > 2) {
                        const first = velocityHistory[0];
                        const last = velocityHistory[velocityHistory.length - 1];
                        const dt = (last.t - first.t) / 1000; // seconds
                        if(dt > 0) {
                            const vx = (last.x - first.x) / dt;
                            const vy = (last.y - first.y) / dt;
                            heldBox.vx = vx * 0.02; // scale down to sensible pixels/frame
                            heldBox.vy = vy * 0.02;
                            // impart some angular velocity based on vx
                            heldBox.av = (vx / 200) * (Math.random() * 2 - 1);
                        }
                    }
                    heldBox.isHeld = false;
                    heldBox.target = null;
                    heldBox = null;
                    velocityHistory = [];
                }
            }

            boxes.forEach(box => {
                box.update(canvasElement.width, canvasElement.height);
                box.draw(canvasCtx);
            });

            canvasCtx.restore();

            // C·∫≠p nh·∫≠t UI vƒÉn b·∫£n
            uiFingers.innerText = `Ng√≥n tay: ${currentFingers}`;
            uiBoxes.innerText = `S·ªë l∆∞·ª£ng h·ªôp: ${boxes.length}`;
            uiStatus.innerText = `Tr·∫°ng th√°i: ${heldBox ? 'ƒêANG C·∫¶M H·ªòP' : (handDetected ? (isPinching ? 'ƒêANG CH·ª§M' : 'S·∫¥N S√ÄNG') : 'T√åM TAY...')}`;
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        camera.start();

        window.addEventListener('resize', () => {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        });
    </script>
</body>
</html>
